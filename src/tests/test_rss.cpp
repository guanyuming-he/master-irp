/**
 * The file is licensed under the GNU GPL v3
 * Copyright (C) Guanyuming He 2025
 *
 * Comprehensive unit tests for the rss class using Boost.Test.
 * Tests cover parsing various RSS feed formats and edge cases.
 *
 * Tests were generated by Calude.ai, and are adjusted by me.
 */

#define BOOST_TEST_MODULE rss_tests
#include <boost/test/included/unit_test.hpp>
#include <boost/test/data/test_case.hpp>

#include <string>
#include <vector>
#include <stdexcept>
#include <chrono>

#include "url2rss.h"
#include "webpage.h"

namespace ch = std::chrono;

// Test fixture for common RSS test data
struct rss_test_fixture {
    // Valid RSS 2.0 feed with multiple items
    const std::string valid_rss_2_0 = R"(<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>Test Blog</title>
    <link>https://example.com</link>
    <description>A test blog for unit testing</description>
    <item>
      <title>First Post</title>
      <link>https://example.com/post1</link>
      <description>This is the first test post</description>
      <pubDate>Mon, 20 Jan 2025 10:00:00 GMT</pubDate>
    </item>
    <item>
      <title>Second Post</title>
      <link>https://example.com/post2</link>
      <description>This is the second test post</description>
      <pubDate>Tue, 21 Jan 2025 15:30:00 GMT</pubDate>
    </item>
    <item>
      <title>Third Post</title>
      <link>https://example.com/post3</link>
      <description>Post without date</description>
    </item>
  </channel>
</rss>)";

    // Valid Atom feed
    const std::string valid_atom = R"(<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Test Atom Feed</title>
  <link href="https://example.com"/>
  <id>https://example.com</id>
  <updated>2025-01-21T10:00:00Z</updated>
  <entry>
    <title>Atom Entry 1</title>
    <link href="https://example.com/atom1"/>
    <id>https://example.com/atom1</id>
    <updated>2025-01-20T10:00:00Z</updated>
    <summary>First atom entry</summary>
  </entry>
  <entry>
    <title>Atom Entry 2</title>
    <link href="https://example.com/atom2"/>
    <id>https://example.com/atom2</id>
    <updated>2025-01-21T15:30:00Z</updated>
    <summary>Second atom entry</summary>
  </entry>
</feed>)";

    // RSS with minimal required fields only
    const std::string minimal_rss = R"(<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>Minimal Feed</title>
    <link>https://minimal.com</link>
    <description>Minimal RSS</description>
    <item>
      <title>Minimal Post</title>
      <link>https://minimal.com/post</link>
    </item>
  </channel>
</rss>)";

    // RSS with empty channel (no items)
    const std::string empty_rss = R"(<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>Empty Feed</title>
    <link>https://empty.com</link>
    <description>Empty RSS</description>
  </channel>
</rss>)";

    // RSS with invalid/malformed URLs
    const std::string invalid_urls_rss = R"(<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>Invalid URLs Feed</title>
    <link>https://example.com</link>
    <description>RSS with invalid URLs</description>
    <item>
      <title>Valid URL Post</title>
      <link>https://example.com/valid</link>
    </item>
    <item>
      <title>Invalid URL Post</title>
      <link>not-a-valid-url</link>
    </item>
    <item>
      <title>Empty URL Post</title>
      <link></link>
    </item>
    <item>
      <title>Missing URL Post</title>
    </item>
  </channel>
</rss>)";

    // RSS with special characters and encoding
    const std::string special_chars_rss = R"(<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>Special Characters Feed</title>
    <link>https://example.com</link>
    <description>RSS with special characters</description>
    <item>
      <title>Post with &amp; &lt; &gt; &quot;</title>
      <link>https://example.com/special</link>
      <description>Content with &amp; special chars</description>
    </item>
    <item>
      <title>Unicode Post: 测试中文</title>
      <link>https://example.com/unicode</link>
    </item>
  </channel>
</rss>)";
};

BOOST_FIXTURE_TEST_SUITE(rss_parsing_tests, rss_test_fixture)

// Test successful parsing of valid RSS 2.0
BOOST_AUTO_TEST_CASE(parse_valid_rss_2_0) {
    BOOST_CHECK_NO_THROW({
        rss feed(valid_rss_2_0);
    });
}

// Test successful parsing of valid Atom feed
BOOST_AUTO_TEST_CASE(parse_valid_atom) {
    BOOST_CHECK_NO_THROW({
        rss feed(valid_atom);
    });
}

// Test parsing minimal RSS
BOOST_AUTO_TEST_CASE(parse_minimal_rss) {
    BOOST_CHECK_NO_THROW({
        rss feed(minimal_rss);
    });
}

// Test parsing empty RSS (no items)
BOOST_AUTO_TEST_CASE(parse_empty_rss) {
    BOOST_CHECK_NO_THROW({
        rss feed(empty_rss);
    });
}

// Test parsing invalid XML
BOOST_AUTO_TEST_CASE(parse_invalid_xml) {
    const std::string invalid_xml = "this is not xml";
    BOOST_CHECK_THROW(rss feed(invalid_xml), std::runtime_error);
}

// Test parsing malformed XML
BOOST_AUTO_TEST_CASE(parse_malformed_xml) {
    const std::string malformed_xml = R"(<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>Unclosed Tag</title>
    <link>https://example.com</link>
  </channel>
</rss>)";
    
    // Note: depending on parser implementation, this might or might not throw
    // Most parsers are tolerant, but we should test both cases
    BOOST_CHECK_NO_THROW({
        rss feed(malformed_xml);
    });
}

// Test parsing empty string
BOOST_AUTO_TEST_CASE(parse_empty_string) {
    const std::string empty_content = "";
    BOOST_CHECK_THROW(rss feed(empty_content), std::runtime_error);
}

// Test parsing non-RSS XML
BOOST_AUTO_TEST_CASE(parse_non_rss_xml) {
    const std::string non_rss = R"(<?xml version="1.0"?>
<html>
  <head><title>Not RSS</title></head>
  <body>This is HTML, not RSS</body>
</html>)";
    
    // Should not throw, but read_webpages should return empty vector
    BOOST_CHECK_NO_THROW({
        rss feed(non_rss);
    });
}

BOOST_AUTO_TEST_SUITE_END()

BOOST_FIXTURE_TEST_SUITE(rss_webpage_reading_tests, rss_test_fixture)

// Test reading webpages from RSS 2.0 feed
BOOST_AUTO_TEST_CASE(read_webpages_rss_2_0) {
    rss feed(valid_rss_2_0);
    auto webpages = feed.read_webpages();
    
    BOOST_REQUIRE_EQUAL(webpages.size(), 3);
    
    // Check first webpage
    BOOST_CHECK_EQUAL(webpages[0].get_title(), "First Post");
    BOOST_CHECK_EQUAL(webpages[0].url.c_str(), "https://example.com/post1");
    // Check date is parsed correctly (should be 2025-01-20)
    auto date1 = webpages[0].get_date();
    BOOST_CHECK_EQUAL(static_cast<int>(date1.year()), 2025);
    BOOST_CHECK_EQUAL(static_cast<unsigned>(date1.month()), 1);
    BOOST_CHECK_EQUAL(static_cast<unsigned>(date1.day()), 20);
    
    // Check second webpage
    BOOST_CHECK_EQUAL(webpages[1].get_title(), "Second Post");
    BOOST_CHECK_EQUAL(webpages[1].url.c_str(), "https://example.com/post2");
    auto date2 = webpages[1].get_date();
    BOOST_CHECK_EQUAL(static_cast<int>(date2.year()), 2025);
    BOOST_CHECK_EQUAL(static_cast<unsigned>(date2.month()), 1);
    BOOST_CHECK_EQUAL(static_cast<unsigned>(date2.day()), 21);
    
    // Check third webpage (no date, should use today)
    BOOST_CHECK_EQUAL(webpages[2].get_title(), "Third Post");
    BOOST_CHECK_EQUAL(webpages[2].url.c_str(), "https://example.com/post3");
    auto date3 = webpages[2].get_date();
    auto today = ch::floor<ch::days>(ch::system_clock::now());
    auto today_ymd = ch::year_month_day{today};
    BOOST_CHECK_EQUAL(static_cast<int>(date3.year()), 
                      static_cast<int>(today_ymd.year()));
    BOOST_CHECK_EQUAL(static_cast<unsigned>(date3.month()), 
                      static_cast<unsigned>(today_ymd.month()));
    BOOST_CHECK_EQUAL(static_cast<unsigned>(date3.day()), 
                      static_cast<unsigned>(today_ymd.day()));
}

// Test reading webpages from Atom feed
BOOST_AUTO_TEST_CASE(read_webpages_atom) {
    rss feed(valid_atom);
    auto webpages = feed.read_webpages();
    
    BOOST_REQUIRE_EQUAL(webpages.size(), 2);
    
    // Check first webpage
    BOOST_CHECK_EQUAL(webpages[0].get_title(), "Atom Entry 1");
    BOOST_CHECK_EQUAL(webpages[0].url.c_str(), "https://example.com/atom1");
    
    // Check second webpage
    BOOST_CHECK_EQUAL(webpages[1].get_title(), "Atom Entry 2");
    BOOST_CHECK_EQUAL(webpages[1].url.c_str(), "https://example.com/atom2");
}

// Test reading from minimal RSS
BOOST_AUTO_TEST_CASE(read_webpages_minimal) {
    rss feed(minimal_rss);
    auto webpages = feed.read_webpages();
    
    BOOST_REQUIRE_EQUAL(webpages.size(), 1);
    BOOST_CHECK_EQUAL(webpages[0].get_title(), "Minimal Post");
    BOOST_CHECK_EQUAL(webpages[0].url.c_str(), "https://minimal.com/post");
}

// Test reading from empty RSS (no items)
BOOST_AUTO_TEST_CASE(read_webpages_empty) {
    rss feed(empty_rss);
    auto webpages = feed.read_webpages();
    
    BOOST_CHECK_EQUAL(webpages.size(), 0);
}

// Test reading with invalid URLs (should skip invalid ones)
BOOST_AUTO_TEST_CASE(read_webpages_invalid_urls) {
    rss feed(invalid_urls_rss);
    auto webpages = feed.read_webpages();
    
    // Should only include the item with valid URL
    BOOST_REQUIRE_EQUAL(webpages.size(), 1);
    BOOST_CHECK_EQUAL(webpages[0].get_title(), "Valid URL Post");
    BOOST_CHECK_EQUAL(webpages[0].url.c_str(), "https://example.com/valid");
}

// Test reading with special characters
BOOST_AUTO_TEST_CASE(read_webpages_special_chars) {
    rss feed(special_chars_rss);
    auto webpages = feed.read_webpages();
    
    BOOST_REQUIRE_EQUAL(webpages.size(), 2);
    
    // Check HTML entities are properly decoded
    BOOST_CHECK_EQUAL(webpages[0].get_title(), "Post with & < > \"");
    BOOST_CHECK_EQUAL(webpages[0].url.c_str(), "https://example.com/special");
    
    // Check Unicode characters
    BOOST_CHECK_EQUAL(webpages[1].get_title(), "Unicode Post: 测试中文");
    BOOST_CHECK_EQUAL(webpages[1].url.c_str(), "https://example.com/unicode");
}

// Test reading from non-RSS XML
BOOST_AUTO_TEST_CASE(read_webpages_non_rss) {
    const std::string non_rss = R"(<?xml version="1.0"?>
<html>
  <head><title>Not RSS</title></head>
  <body>This is HTML, not RSS</body>
</html>)";
    
    rss feed(non_rss);
    auto webpages = feed.read_webpages();
    
    BOOST_CHECK_EQUAL(webpages.size(), 0);
}

// Test that HTML content is not loaded for webpages
BOOST_AUTO_TEST_CASE(webpages_html_not_loaded) {
    rss feed(valid_rss_2_0);
    auto webpages = feed.read_webpages();
    
    BOOST_REQUIRE_GT(webpages.size(), 0);
    
    // Check that HTML text is empty (not loaded)
    for (const auto& webpage : webpages) {
        BOOST_CHECK_EQUAL(webpage.get_text(), "");
    }
}

BOOST_AUTO_TEST_SUITE_END()

BOOST_FIXTURE_TEST_SUITE(rss_move_semantics_tests, rss_test_fixture)

// Test move constructor
BOOST_AUTO_TEST_CASE(move_constructor) {
    rss original(valid_rss_2_0);
    auto original_webpages = original.read_webpages();
    
    rss moved(std::move(original));
    auto moved_webpages = moved.read_webpages();
    
    BOOST_CHECK_EQUAL(moved_webpages.size(), original_webpages.size());
    for (size_t i = 0; i < moved_webpages.size(); ++i) {
        BOOST_CHECK_EQUAL(moved_webpages[i].get_title(), 
                          original_webpages[i].get_title());
        BOOST_CHECK_EQUAL(moved_webpages[i].url.c_str(), 
                          original_webpages[i].url.c_str());
    }
}

// Test move assignment
BOOST_AUTO_TEST_CASE(move_assignment) {
    rss original(valid_rss_2_0);
    auto original_webpages = original.read_webpages();
    
    rss target(minimal_rss);
    target = std::move(original);
    
    auto target_webpages = target.read_webpages();
    BOOST_CHECK_EQUAL(target_webpages.size(), original_webpages.size());
    for (size_t i = 0; i < target_webpages.size(); ++i) {
        BOOST_CHECK_EQUAL(target_webpages[i].get_title(), 
                          original_webpages[i].get_title());
        BOOST_CHECK_EQUAL(target_webpages[i].url.c_str(), 
                          original_webpages[i].url.c_str());
    }
}

BOOST_AUTO_TEST_SUITE_END()

BOOST_FIXTURE_TEST_SUITE(rss_edge_cases_tests, rss_test_fixture)

// Test RSS with very long content
BOOST_AUTO_TEST_CASE(long_content) {
    const std::string long_title(10000, 'A');
    const std::string long_rss = R"(<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>Long Content Feed</title>
    <link>https://example.com</link>
    <description>RSS with long content</description>
    <item>
      <title>)" + long_title + R"(</title>
      <link>https://example.com/long</link>
    </item>
  </channel>
</rss>)";
    
    BOOST_CHECK_NO_THROW({
        rss feed(long_rss);
        auto webpages = feed.read_webpages();
        BOOST_REQUIRE_EQUAL(webpages.size(), 1);
        BOOST_CHECK_EQUAL(webpages[0].get_title(), long_title);
    });
}

// Test RSS with multiple namespaces
BOOST_AUTO_TEST_CASE(namespaces) {
    const std::string namespaced_rss = R"(<?xml version="1.0"?>
<rss version="2.0" 
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Namespaced Feed</title>
    <link>https://example.com</link>
    <description>RSS with namespaces</description>
    <item>
      <title>Namespaced Post</title>
      <link>https://example.com/namespaced</link>
      <dc:creator>John Doe</dc:creator>
      <content:encoded><![CDATA[<p>HTML content</p>]]></content:encoded>
    </item>
  </channel>
</rss>)";
    
    BOOST_CHECK_NO_THROW({
        rss feed(namespaced_rss);
        auto webpages = feed.read_webpages();
        BOOST_REQUIRE_EQUAL(webpages.size(), 1);
        BOOST_CHECK_EQUAL(webpages[0].get_title(), "Namespaced Post");
    });
}

// Test RSS with CDATA sections
BOOST_AUTO_TEST_CASE(cdata_content) {
    const std::string cdata_rss = R"(<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>CDATA Feed</title>
    <link>https://example.com</link>
    <description>RSS with CDATA</description>
    <item>
      <title><![CDATA[Post with <HTML> & "quotes"]]></title>
      <link>https://example.com/cdata</link>
      <description><![CDATA[Content with <b>HTML</b> & special chars]]></description>
    </item>
  </channel>
</rss>)";
    
    rss feed(cdata_rss);
    auto webpages = feed.read_webpages();
    
    BOOST_REQUIRE_EQUAL(webpages.size(), 1);
    BOOST_CHECK_EQUAL(webpages[0].get_title(), "Post with <HTML> & \"quotes\"");
}

BOOST_AUTO_TEST_SUITE_END()
